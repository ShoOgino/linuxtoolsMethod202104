    private void updatePreviews(boolean updateAll) {
        if (inputText == null) {
            // early update during construction
            return;
        }
        inputText.setStyleRanges(new StyleRange[] {});
        
        Scanner scanner = new Scanner(inputText.getText());
        scanner.useDelimiter("\n");
        int rawPos = 0;
        String skip; // skip starting delimiters
        if ((skip = scanner.findWithinHorizon("\\A\n+", 0)) != null) {
            rawPos += skip.length();
        }
        
        timeStampFormat = null;
        if (selectedLine != null) {
            for (InputGroup input : selectedLine.inputs) {
                input.previewText.setText("*no matching line*");
            }
        }
        
        Map<String, String> data = new HashMap<String, String>();
        int rootLineMatches = 0;
        String firstEntryTimeStamp = null;
        String firstEntryTimeStampInputFormat = null;
        String log = null;
    event: 
        while (log != null || scanner.hasNext()) {
            if (rootLineMatches > 0 && !updateAll) {
                break;
            }
            if (log == null) {
                log = scanner.next();
            }
            int length = log.length();
            for (InputLine rootInputLine : definition.inputs) {
                Pattern pattern;
                try {
                    pattern = rootInputLine.getPattern();
                } catch (PatternSyntaxException e) {
                    continue;
                }
                Matcher matcher = pattern.matcher(log);
                if (matcher.find()) {
                    rootLineMatches++;
                    inputText.setStyleRange(new StyleRange(rawPos, length,
                            COLOR_BLACK, COLOR_YELLOW, SWT.ITALIC));
                    data = new HashMap<String, String>();
                    timeStampFormat = null;
                    updatePreviewLine(rootInputLine, matcher, data, rawPos, rootLineMatches);
                    if (rootLineMatches == 1) {
                        firstEntryTimeStamp = data.get(CustomTxtTraceDefinition.TAG_TIMESTAMP);
                        firstEntryTimeStampInputFormat = timeStampFormat;
                    }
                    HashMap<InputLine, Integer> countMap = new HashMap<InputLine, Integer>();
                    InputLine currentInput = null;
                    if (rootInputLine.childrenInputs != null && rootInputLine.childrenInputs.size() > 0) {
                        currentInput = rootInputLine.childrenInputs.get(0);
                        countMap.put(currentInput, 0);
                    }
                    rawPos += length + 1; // +1 for \n
                    while (scanner.hasNext()) {
                        log = scanner.next();
                        length = log.length();
                        boolean processed = false;
                        if (currentInput == null) {
                            for (InputLine input : definition.inputs) {
                                matcher = input.getPattern().matcher(log);
                                if (matcher.find()) {
                                    continue event;
                                }
                            }
                        } else {
                            if (countMap.get(currentInput) >= currentInput.getMinCount()) {
                                List<InputLine> nextInputs = currentInput.getNextInputs(countMap);
                                if (nextInputs.size() == 0 || nextInputs.get(nextInputs.size() - 1).getMinCount() == 0) {
                                    for (InputLine input : definition.inputs) {
                                        matcher = input.getPattern().matcher(log);
                                        if (matcher.find()) {
                                            continue event;
                                        }
                                    }
                                }
                                for (InputLine input : nextInputs) {
                                    matcher = input.getPattern().matcher(log);
                                    if (matcher.find()) {
                                        inputText.setStyleRange(new StyleRange(rawPos, length,
                                                COLOR_BLACK, COLOR_LIGHT_YELLOW, SWT.ITALIC));
                                        currentInput = input;
                                        updatePreviewLine(currentInput, matcher, data, rawPos, rootLineMatches);
                                        if (countMap.get(currentInput) == null) {
                                            countMap.put(currentInput, 1);
                                        } else {
                                            countMap.put(currentInput, countMap.get(currentInput) + 1);
                                        }
                                        Iterator<InputLine> iter = countMap.keySet().iterator();
                                        while (iter.hasNext()) {
                                            InputLine inputLine = iter.next();
                                            if (inputLine.level > currentInput.level) {
                                                iter.remove();
                                            }
                                        }
                                        if (currentInput.childrenInputs != null && currentInput.childrenInputs.size() > 0) {
                                            currentInput = currentInput.childrenInputs.get(0);
                                            countMap.put(currentInput, 0);
                                        } else {
                                            if (countMap.get(currentInput) >= currentInput.getMaxCount()) {
                                                if (currentInput.getNextInputs(countMap).size() > 0) {
                                                    currentInput = currentInput.getNextInputs(countMap).get(0);
                                                    if (countMap.get(currentInput) == null) {
                                                        countMap.put(currentInput, 0);
                                                    }
                                                    iter = countMap.keySet().iterator();
                                                    while (iter.hasNext()) {
                                                        InputLine inputLine = iter.next();
                                                        if (inputLine.level > currentInput.level) {
                                                            iter.remove();
                                                        }
                                                    }
                                                } else {
                                                    currentInput = null;
                                                }
                                            }
                                        }
                                        processed = true;
                                        break;
                                    }
                                }
                            }
                            if (! processed) {
                                matcher = currentInput.getPattern().matcher(log);
                                if (matcher.find()) {
                                    inputText.setStyleRange(new StyleRange(rawPos, length,
                                            COLOR_BLACK, COLOR_LIGHT_YELLOW, SWT.ITALIC));
                                    updatePreviewLine(currentInput, matcher, data, rawPos, rootLineMatches);
                                    countMap.put(currentInput, countMap.get(currentInput) + 1);
                                    if (currentInput.childrenInputs != null && currentInput.childrenInputs.size() > 0) {
                                        currentInput = currentInput.childrenInputs.get(0);
                                        countMap.put(currentInput, 0);
                                    } else {
                                        if (countMap.get(currentInput) >= currentInput.getMaxCount()) {
                                            if (currentInput.getNextInputs(countMap).size() > 0) {
                                                currentInput = currentInput.getNextInputs(countMap).get(0);
                                                if (countMap.get(currentInput) == null) {
                                                    countMap.put(currentInput, 0);
                                                }
                                                Iterator<InputLine> iter = countMap.keySet().iterator();
                                                while (iter.hasNext()) {
                                                    InputLine inputLine = iter.next();
                                                    if (inputLine.level > currentInput.level) {
                                                        iter.remove();
                                                    }
                                                }
                                            } else {
                                                currentInput = null;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        rawPos += length + 1; // +1 for \n
                    }

                    break;
                }
            }
            rawPos += length + 1; // +1 for \n
            log = null;
        }
        scanner.close();
        if (rootLineMatches == 1) {
            firstEntryTimeStamp = data.get(CustomTxtTraceDefinition.TAG_TIMESTAMP);
            firstEntryTimeStampInputFormat = timeStampFormat;
        }
        if (firstEntryTimeStamp == null) {
            timestampPreviewText.setText("*no timestamp group*");
            if (selectedLine != null) {
                for (InputGroup group : selectedLine.inputs) {
                    if (group.tagCombo.getText().equals(CustomTxtTraceDefinition.TAG_TIMESTAMP)) {
                        timestampPreviewText.setText("*no matching timestamp*");
                        break;
                    }
                }
            }
        } else {
            try {
                SimpleDateFormat dateFormat = new SimpleDateFormat(firstEntryTimeStampInputFormat);
                Date date = dateFormat.parse(firstEntryTimeStamp);
                dateFormat = new SimpleDateFormat(timestampOutputFormatText.getText().trim());
                timestampPreviewText.setText(dateFormat.format(date));
            } catch (ParseException e) {
                timestampPreviewText.setText("*parse exception* [" + firstEntryTimeStamp + "] <> [" + firstEntryTimeStampInputFormat + "]");
            } catch (IllegalArgumentException e) {
                timestampPreviewText.setText("*parse exception* [Illegal Argument]");
            }

        }
    }

