    private synchronized void populateCache(final int index) {

        /* Check if the current job will fetch the requested event:
         * 1. The job must exist
         * 2. It must be running (i.e. not completed)
         * 3. The requested index must be within the cache range
         * 
         * If the job meets these conditions, we simply exit.
         * Otherwise, we create a new job but we might have to cancel
         * an existing job for an obsolete range.
         */
        if (job != null) {
            if (job.getState() != Job.NONE) {
                if (index >= fCacheStartIndex && index < (fCacheStartIndex + fCache.length)) {
                    return;
                }
                // The new index is out of the requested range
                // Kill the job and start a new one
                job.cancel();
            }
        }
        
        fCacheStartIndex = index;
        fCacheEndIndex   = index;

        job = new Job("Fetching Events") { //$NON-NLS-1$
        	private int startIndex = index;
        	private int skipCount = 0;
            @Override
            @SuppressWarnings("unchecked")
            protected IStatus run(final IProgressMonitor monitor) {

            	int nbRequested;
            	if (fFilter == null) {
            		nbRequested = fCache.length;
            	} else {
            		nbRequested = TmfDataRequest.ALL_DATA;
            		int i = index / fCache.length;
            		if (i < fFilterIndex.size()) {
            			startIndex = fFilterIndex.get(i);
            			skipCount = index - (i * fCache.length);
            		}
            	}
            	
                TmfDataRequest<TmfEvent> request = new TmfDataRequest<TmfEvent>(TmfEvent.class, startIndex, nbRequested) {
                    private int count = 0;
                    private long rank = startIndex;
                    @Override
                    public void handleData(TmfEvent event) {
                        // If the job is canceled, cancel the request so waitForCompletion() will unlock
                        if (monitor.isCanceled()) {
                            cancel();
                            return;
                        }
                        super.handleData(event);
                        if (event != null) {
                        	if ((fFilter == null || fFilter.matches(event)) && skipCount-- <= 0) {
                        		synchronized (TmfEventsCache.this) {
                        			fCache[count] = new CachedEvent(event.clone(), rank);
                        			count++;
                        			fCacheEndIndex++;
                        		}
                                if (fFilter != null) {
                                	fTable.cacheUpdated(false);
                                }
                        	}
                        }
                        if (count >= fCache.length) {
                        	cancel();
                        } else if (fFilter != null && count >= fTable.getTable().getItemCount() - 3) { // -1 for header row, -2 for top and bottom filter status rows
                        	cancel();
                        }
                        rank++;
                    }
                };

                ((ITmfDataProvider<TmfEvent>) fTrace).sendRequest(request);
                try {
                    request.waitForCompletion();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                fTable.cacheUpdated(true);
                
                // Flag the UI thread that the cache is ready
                if (monitor.isCanceled()) {
                	return Status.CANCEL_STATUS;
                } else {
                    return Status.OK_STATUS;
                }
            }
        };
        //job.setSystem(true);
        job.setPriority(Job.SHORT);
        job.schedule();
    }

