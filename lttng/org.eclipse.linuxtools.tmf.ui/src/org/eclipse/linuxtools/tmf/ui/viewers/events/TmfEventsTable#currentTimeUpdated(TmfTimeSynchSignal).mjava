    @SuppressWarnings("unchecked")
    @TmfSignalHandler
    public void currentTimeUpdated(final TmfTimeSynchSignal signal) {
    	if ((signal.getSource() != fTable) && (fTrace != null) && (!fTable.isDisposed())) {

    		// Create a request for one event that will be queued after other ongoing requests. When this request is completed 
    		// do the work to select the actual event with the timestamp specified in the signal. This procedure prevents 
    		// the method fTrace.getRank() from interfering and delaying ongoing requests.
    		final TmfDataRequest<TmfEvent> subRequest = new TmfDataRequest<TmfEvent>(TmfEvent.class, 0, 1, ExecutionType.FOREGROUND) {

    			@Override
    			public void handleData(TmfEvent event) {
    				super.handleData(event);
    			}

    			@Override
    			public void handleCompleted() {

    				// Verify if event is within the trace range
    				final TmfTimestamp timestamp[] = new TmfTimestamp[1];
    				timestamp[0] = signal.getCurrentTime();
    				if (timestamp[0].compareTo(fTrace.getStartTime(), true) == -1) {
    					timestamp[0] = fTrace.getStartTime();
    				}
    				if (timestamp[0].compareTo(fTrace.getEndTime(), true) == 1) {
    					timestamp[0] = fTrace.getEndTime();
    				}

    				// Get the rank for the event selection in the table
    				final long rank = fTrace.getRank(timestamp[0]);
    				fSelectedRank = rank;

    				fTable.getDisplay().asyncExec(new Runnable() {
    					@Override
                        public void run() {
    						// Return if table is disposed
    						if (fTable.isDisposed()) return;

                            int index = (int) rank;
                            if (fTable.isDisposed()) return;
                            if (fTable.getData(Key.FILTER_OBJ) != null) {
                            	index = getFilteredEventIndex(rank) + 1; //+1 for top filter status row
                            }
                            fTable.setSelection(index + 1); // +1 for header row
                            fRawViewer.selectAndReveal(rank);
    					}
    				});
    				super.handleCompleted();
    			}
    		};

            ((ITmfDataProvider<TmfEvent>) fTrace).sendRequest(subRequest);
    	}
	}

