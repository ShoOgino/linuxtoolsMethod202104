	/**
	 * Initializes the given line number ruler column from the preference store.
	 */
	private void initialize() {
		final IPreferenceStore store= getPreferenceStore();
		if (store == null)
			return;

		// initial set up
		updateForegroundColor(store, fDelegate);
		updateBackgroundColor(store, fDelegate);
		
		updateLineNumbersVisibility(fDelegate);
		updateQuickDiffVisibility(fDelegate);
		updateCharacterMode(store, fDelegate);
		updateRevisionRenderingMode(store, fDelegate);
		updateRevisionAuthorVisibility(store, fDelegate);
		updateRevisionIdVisibility(store, fDelegate);

		Map<Object, AnnotationPreference> annotationPrefs= getAnnotationPreferenceMap();
		final AnnotationPreference changedPref= annotationPrefs.get("org.eclipse.ui.workbench.texteditor.quickdiffChange"); //$NON-NLS-1$
		final AnnotationPreference addedPref= annotationPrefs.get("org.eclipse.ui.workbench.texteditor.quickdiffAddition"); //$NON-NLS-1$
		final AnnotationPreference deletedPref= annotationPrefs.get("org.eclipse.ui.workbench.texteditor.quickdiffDeletion"); //$NON-NLS-1$
		updateChangedColor(changedPref, store, fDelegate);
		updateAddedColor(addedPref, store, fDelegate);
		updateDeletedColor(deletedPref, store, fDelegate);

		if (fDelegate != null)
			fDelegate.redraw();

		// listen to changes
		fDispatcher= new PropertyEventDispatcher(store);

		fDispatcher.addPropertyChangeListener(FG_COLOR_KEY, new IPropertyChangeListener() {
			public void propertyChange(PropertyChangeEvent event) {
				updateForegroundColor(store, fDelegate);
				fDelegate.redraw();
			}
		});
		IPropertyChangeListener backgroundHandler= new IPropertyChangeListener() {
			public void propertyChange(PropertyChangeEvent event) {
				updateBackgroundColor(store, fDelegate);
				fDelegate.redraw();
			}
		};
		fDispatcher.addPropertyChangeListener(BG_COLOR_KEY, backgroundHandler);
		fDispatcher.addPropertyChangeListener(USE_DEFAULT_BG_KEY, backgroundHandler);

		fDispatcher.addPropertyChangeListener(ST_KEY, new IPropertyChangeListener() {
			public void propertyChange(PropertyChangeEvent event) {
				// only handle quick diff on/off information, but not ruler visibility (handled by AbstractDecoratedTextEditor)
				
				updateLineNumbersVisibility(fDelegate);
			}
		});

		fDispatcher.addPropertyChangeListener(AbstractDecoratedTextEditorPreferenceConstants.QUICK_DIFF_CHARACTER_MODE, new IPropertyChangeListener() {
			public void propertyChange(PropertyChangeEvent event) {
				updateCharacterMode(store, fDelegate);
			}
		});

		fDispatcher.addPropertyChangeListener(AbstractDecoratedTextEditorPreferenceConstants.REVISION_RULER_RENDERING_MODE, new IPropertyChangeListener() {
			public void propertyChange(PropertyChangeEvent event) {
				updateRevisionRenderingMode(store, fDelegate);
			}
		});
		
		fDispatcher.addPropertyChangeListener(AbstractDecoratedTextEditorPreferenceConstants.REVISION_RULER_SHOW_AUTHOR, new IPropertyChangeListener() {
			public void propertyChange(PropertyChangeEvent event) {
				updateRevisionAuthorVisibility(store, fDelegate);
			}
		});
		
		fDispatcher.addPropertyChangeListener(AbstractDecoratedTextEditorPreferenceConstants.REVISION_RULER_SHOW_REVISION, new IPropertyChangeListener() {
			public void propertyChange(PropertyChangeEvent event) {
				updateRevisionIdVisibility(store, fDelegate);
			}
		});
		
		fDispatcher.addPropertyChangeListener(AbstractDecoratedTextEditorPreferenceConstants.QUICK_DIFF_ALWAYS_ON, new IPropertyChangeListener() {
			public void propertyChange(PropertyChangeEvent event) {
				updateQuickDiffVisibility(fDelegate);
			}
		});

		if (changedPref != null) {
			fDispatcher.addPropertyChangeListener(changedPref.getColorPreferenceKey(), new IPropertyChangeListener() {
				public void propertyChange(PropertyChangeEvent event) {
					updateChangedColor(changedPref, store, fDelegate);
					fDelegate.redraw();
				}
			});
		}
		if (addedPref != null) {
			fDispatcher.addPropertyChangeListener(addedPref.getColorPreferenceKey(), new IPropertyChangeListener() {
				public void propertyChange(PropertyChangeEvent event) {
					updateAddedColor(addedPref, store, fDelegate);
					fDelegate.redraw();
				}
			});
		}
		if (deletedPref != null) {
			fDispatcher.addPropertyChangeListener(deletedPref.getColorPreferenceKey(), new IPropertyChangeListener() {
				public void propertyChange(PropertyChangeEvent event) {
					updateDeletedColor(deletedPref, store, fDelegate);
					fDelegate.redraw();
				}
			});
		}
	}

