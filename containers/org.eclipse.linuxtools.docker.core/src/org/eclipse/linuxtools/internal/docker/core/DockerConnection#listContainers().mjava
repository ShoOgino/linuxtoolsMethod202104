	private List<IDockerContainer> listContainers() throws DockerException {
		final Map<String, IDockerContainer> updatedContainers = new HashMap<>();
		try {
			final List<Container> nativeContainers = new ArrayList<>();
			synchronized (clientLock) {
				// Check that client is not null as this connection may have
				// been closed but there is an async request to update the
				// containers list left in the queue
				if (client == null) {
					// in that case the list becomes empty, which is fine is
					// there's no client.
					return Collections.emptyList();
				}
				nativeContainers.addAll(client.listContainers(
						DockerClient.ListContainersParam.allContainers()));
			}
			// We have a list of containers. Now, we translate them to our own
			// core format in case we decide to change the underlying engine
			// in the future.
			for (Container nativeContainer : nativeContainers) {
				// For containers that have exited, make sure we aren't tracking
				// them with a logging thread.
				if (nativeContainer.status() != null && nativeContainer.status()
						.startsWith(Messages.Exited_specifier)) {
					synchronized (loggingThreads) {
						if (loggingThreads.containsKey(nativeContainer.id())) {
							loggingThreads.get(nativeContainer.id())
									.requestStop();
							loggingThreads.remove(nativeContainer.id());
						}
					}
				}
				// skip containers that are being removed
				if (nativeContainer.status() != null && nativeContainer.status()
						.equals(Messages.Removal_In_Progress_specifier)) {
					continue;
				}
				// re-use info from existing container with same id
				if (this.containers != null && this.containersById
						.containsKey(nativeContainer.id())) {
					final IDockerContainer container = this.containersById
							.get(nativeContainer.id());
					updatedContainers.put(nativeContainer.id(),
							new DockerContainer(this, nativeContainer,
									container.info()));
				} else {
					updatedContainers.put(nativeContainer.id(),
							new DockerContainer(this, nativeContainer));
				}
			}
		} catch (DockerTimeoutException e) {
			if (isOpen()) {
				Activator.log(new Status(IStatus.WARNING, Activator.PLUGIN_ID,
						Messages.Docker_Connection_Timeout, e));
				close();
			}
		} catch (com.spotify.docker.client.DockerException
				| InterruptedException e) {
			if (isOpen() && e.getCause() != null
					&& e.getCause().getCause() != null
					&& e.getCause().getCause() instanceof ProcessingException) {
				close();
			} else {
				throw new DockerException(e.getMessage());
			}
		} finally {
			// assign the new list of containers in a locked block of code to
			// prevent concurrent access, even if an exception was raised.
			synchronized (containerLock) {
				this.containersById = updatedContainers;
				this.containers = sort(this.containersById.values(),
						(container, otherContainer) -> container.name()
								.compareTo(otherContainer.name()));

				this.containersLoaded = true;
			}
		}

		// perform notification outside of containerLock so we don't have a View
		// causing a deadlock
		// TODO: we should probably notify the listeners only if the containers
		// list changed.
		notifyContainerListeners(this.containers);
		return this.containers;
	}

